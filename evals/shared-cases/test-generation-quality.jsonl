{"id": "tg-001", "prompt": "Generate comprehensive tests for this Rails service:\n```ruby\nclass PaymentService\n  def initialize(user, amount, currency: 'USD')\n    @user = user\n    @amount = amount\n    @currency = currency\n  end\n\n  def charge!\n    raise ArgumentError, 'Amount must be positive' if @amount <= 0\n    raise 'User has no payment method' unless @user.payment_method\n\n    result = Stripe::Charge.create(\n      amount: (@amount * 100).to_i,\n      currency: @currency,\n      customer: @user.stripe_customer_id\n    )\n\n    Payment.create!(\n      user: @user,\n      amount: @amount,\n      currency: @currency,\n      stripe_charge_id: result.id,\n      status: 'completed'\n    )\n  rescue Stripe::CardError => e\n    Payment.create!(user: @user, amount: @amount, currency: @currency, status: 'failed', error_message: e.message)\n    raise PaymentFailedError, e.message\n  end\nend\n```", "expected_behavior": "Tests should cover: happy path, zero/negative amount, missing payment method, Stripe API failure, card error handling, currency parameter, payment record creation for both success and failure", "stack": "rails", "rubric": "Must test happy path with mocked Stripe. Must test ArgumentError for non-positive amounts. Must test missing payment method. Must test Stripe::CardError handling. Should verify Payment records are created with correct attributes. Should test currency parameter. Should use proper RSpec patterns (let, context blocks, described_class)."}
{"id": "tg-002", "prompt": "Generate tests for this React custom hook:\n```typescript\nimport { useState, useEffect, useCallback } from 'react';\n\ninterface PaginatedResponse<T> {\n  data: T[];\n  total: number;\n  page: number;\n  perPage: number;\n}\n\nexport function usePagination<T>(url: string, perPage: number = 10) {\n  const [data, setData] = useState<T[]>([]);\n  const [page, setPage] = useState(1);\n  const [total, setTotal] = useState(0);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n\n  const fetchPage = useCallback(async (pageNum: number) => {\n    setLoading(true);\n    setError(null);\n    try {\n      const res = await fetch(`${url}?page=${pageNum}&perPage=${perPage}`);\n      if (!res.ok) throw new Error(`HTTP ${res.status}`);\n      const json: PaginatedResponse<T> = await res.json();\n      setData(json.data);\n      setTotal(json.total);\n      setPage(json.page);\n    } catch (err) {\n      setError(err as Error);\n    } finally {\n      setLoading(false);\n    }\n  }, [url, perPage]);\n\n  useEffect(() => { fetchPage(1); }, [fetchPage]);\n\n  const nextPage = () => fetchPage(page + 1);\n  const prevPage = () => page > 1 && fetchPage(page - 1);\n  const totalPages = Math.ceil(total / perPage);\n\n  return { data, page, total, totalPages, loading, error, nextPage, prevPage, fetchPage };\n}\n```", "expected_behavior": "Tests should cover: initial fetch on mount, loading states, successful data fetch, HTTP error handling, network error handling, next/prev page navigation, prev page boundary (page 1), totalPages calculation, URL and perPage changes triggering refetch", "stack": "react", "rubric": "Must use @testing-library/react-hooks or renderHook. Must test initial loading state. Must test successful data rendering. Must test error states (HTTP error and network error). Should test pagination navigation. Should test that prevPage does nothing on page 1. Should mock fetch properly. Should test cleanup/unmount behavior."}
{"id": "tg-003", "prompt": "Generate tests for this Python data processing service:\n```python\nimport csv\nfrom datetime import datetime\nfrom typing import List, Dict, Optional\nfrom dataclasses import dataclass\n\n@dataclass\nclass SalesRecord:\n    date: datetime\n    product: str\n    quantity: int\n    unit_price: float\n    region: str\n\nclass SalesAnalyzer:\n    def __init__(self, records: List[SalesRecord]):\n        self.records = records\n\n    @classmethod\n    def from_csv(cls, filepath: str) -> 'SalesAnalyzer':\n        records = []\n        with open(filepath, 'r') as f:\n            reader = csv.DictReader(f)\n            for row in reader:\n                records.append(SalesRecord(\n                    date=datetime.strptime(row['date'], '%Y-%m-%d'),\n                    product=row['product'],\n                    quantity=int(row['quantity']),\n                    unit_price=float(row['unit_price']),\n                    region=row['region']\n                ))\n        return cls(records)\n\n    def total_revenue(self, region: Optional[str] = None) -> float:\n        filtered = self.records\n        if region:\n            filtered = [r for r in filtered if r.region == region]\n        return sum(r.quantity * r.unit_price for r in filtered)\n\n    def top_products(self, n: int = 5) -> List[Dict]:\n        product_revenue = {}\n        for r in self.records:\n            revenue = r.quantity * r.unit_price\n            product_revenue[r.product] = product_revenue.get(r.product, 0) + revenue\n        sorted_products = sorted(product_revenue.items(), key=lambda x: x[1], reverse=True)\n        return [{'product': p, 'revenue': r} for p, r in sorted_products[:n]]\n\n    def monthly_trend(self) -> List[Dict]:\n        monthly = {}\n        for r in self.records:\n            key = r.date.strftime('%Y-%m')\n            monthly[key] = monthly.get(key, 0) + r.quantity * r.unit_price\n        return [{'month': k, 'revenue': v} for k, v in sorted(monthly.items())]\n```", "expected_behavior": "Tests should cover: from_csv loading, total_revenue with and without region filter, top_products ordering and limit, monthly_trend aggregation and sorting, empty records, single record, invalid CSV data, edge cases like zero quantity", "stack": "python", "rubric": "Must test from_csv with a fixture/temp file. Must test total_revenue with and without region filter. Must test top_products returns correct order and respects n limit. Should test monthly_trend groups and sorts correctly. Should test empty records list. Should test edge cases (zero quantity, negative prices). Should use pytest fixtures for test data. Should use tmp_path for CSV file tests."}
{"id": "tg-004", "prompt": "Generate tests for this Node.js authentication middleware:\n```typescript\nimport { Request, Response, NextFunction } from 'express';\nimport jwt from 'jsonwebtoken';\n\ninterface AuthenticatedRequest extends Request {\n  user?: { id: string; email: string; role: string };\n}\n\nexport function authenticate(req: AuthenticatedRequest, res: Response, next: NextFunction) {\n  const authHeader = req.headers.authorization;\n\n  if (!authHeader) {\n    return res.status(401).json({ error: 'No authorization header' });\n  }\n\n  if (!authHeader.startsWith('Bearer ')) {\n    return res.status(401).json({ error: 'Invalid authorization format' });\n  }\n\n  const token = authHeader.slice(7);\n\n  try {\n    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as { id: string; email: string; role: string };\n    req.user = decoded;\n    next();\n  } catch (err) {\n    if (err instanceof jwt.TokenExpiredError) {\n      return res.status(401).json({ error: 'Token expired' });\n    }\n    return res.status(401).json({ error: 'Invalid token' });\n  }\n}\n\nexport function authorize(...roles: string[]) {\n  return (req: AuthenticatedRequest, res: Response, next: NextFunction) => {\n    if (!req.user) {\n      return res.status(401).json({ error: 'Not authenticated' });\n    }\n    if (!roles.includes(req.user.role)) {\n      return res.status(403).json({ error: 'Insufficient permissions' });\n    }\n    next();\n  };\n}\n```", "expected_behavior": "Tests should cover: missing auth header, wrong format (not Bearer), valid token decoding, expired token, invalid/malformed token, user attached to request, authorize with correct role, authorize with wrong role, authorize without user, multiple allowed roles", "stack": "node", "rubric": "Must test all authenticate error paths (no header, wrong format, expired, invalid). Must test successful authentication with user on request. Must test authorize role checking. Should mock jwt.verify properly. Should test authorize with multiple roles. Should use proper mock request/response objects. Should test that next() is called on success."}
{"id": "tg-005", "prompt": "Generate tests for this Go HTTP handler:\n```go\npackage handlers\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n)\n\ntype Item struct {\n\tID    int    `json:\"id\"`\n\tName  string `json:\"name\"`\n\tPrice float64 `json:\"price\"`\n}\n\ntype ItemStore interface {\n\tGetAll() ([]Item, error)\n\tGetByID(id int) (*Item, error)\n\tCreate(name string, price float64) (*Item, error)\n\tDelete(id int) error\n}\n\ntype ItemHandler struct {\n\tstore ItemStore\n}\n\nfunc NewItemHandler(store ItemStore) *ItemHandler {\n\treturn &ItemHandler{store: store}\n}\n\nfunc (h *ItemHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tswitch r.Method {\n\tcase http.MethodGet:\n\t\tif id := extractID(r.URL.Path); id > 0 {\n\t\t\th.getItem(w, id)\n\t\t} else {\n\t\t\th.listItems(w)\n\t\t}\n\tcase http.MethodPost:\n\t\th.createItem(w, r)\n\tcase http.MethodDelete:\n\t\tif id := extractID(r.URL.Path); id > 0 {\n\t\t\th.deleteItem(w, id)\n\t\t} else {\n\t\t\thttp.Error(w, \"ID required\", http.StatusBadRequest)\n\t\t}\n\tdefault:\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t}\n}\n\nfunc extractID(path string) int {\n\tparts := strings.Split(strings.Trim(path, \"/\"), \"/\")\n\tif len(parts) < 2 {\n\t\treturn 0\n\t}\n\tid, _ := strconv.Atoi(parts[len(parts)-1])\n\treturn id\n}\n```", "expected_behavior": "Tests should cover: GET list all items, GET single item by ID, POST create item, DELETE item, method not allowed, store errors, invalid JSON body, item not found, proper HTTP status codes", "stack": "go", "rubric": "Must use httptest for request/response. Must use a mock ItemStore implementation. Must test all HTTP methods. Should test error cases (store failures, not found, invalid input). Should verify response status codes and JSON bodies. Should test extractID helper. Should follow Go testing conventions (table-driven tests)."}
{"id": "tg-006", "prompt": "Generate tests for this Rails concern:\n```ruby\nmodule Searchable\n  extend ActiveSupport::Concern\n\n  included do\n    scope :search, ->(query) {\n      return all if query.blank?\n      columns = searchable_columns.map { |col| \"#{table_name}.#{col} ILIKE :query\" }\n      where(columns.join(' OR '), query: \"%#{sanitize_sql_like(query)}%\")\n    }\n\n    scope :filter_by, ->(filters) {\n      result = all\n      filters.each do |key, value|\n        next if value.blank?\n        if column_names.include?(key.to_s)\n          result = result.where(key => value)\n        end\n      end\n      result\n    }\n\n    scope :sort_by_field, ->(field, direction = 'asc') {\n      direction = %w[asc desc].include?(direction.to_s.downcase) ? direction.downcase : 'asc'\n      if column_names.include?(field.to_s)\n        order(field => direction)\n      else\n        order(created_at: :desc)\n      end\n    }\n  end\n\n  class_methods do\n    def searchable_columns\n      raise NotImplementedError, \"#{name} must define searchable_columns\"\n    end\n  end\nend\n```", "expected_behavior": "Tests should cover: search with matching query, search with blank query returns all, search SQL injection safety, filter_by with valid columns, filter_by ignores blank values, filter_by ignores invalid columns, sort_by_field with valid column and direction, sort_by_field defaults for invalid column/direction, searchable_columns must be defined", "stack": "rails", "rubric": "Must test search scope with matching and non-matching queries. Must test blank query returns all records. Must test filter_by with valid and invalid column names. Must test sort_by_field direction validation. Should test SQL injection protection via sanitize_sql_like. Should test NotImplementedError for missing searchable_columns. Should use a test model or shared_examples. Should test filter_by ignores blank values."}
{"id": "tg-007", "prompt": "Generate tests for this React form component:\n```tsx\nimport React, { useState } from 'react';\n\ninterface ContactFormProps {\n  onSubmit: (data: ContactData) => Promise<void>;\n  initialValues?: Partial<ContactData>;\n}\n\ninterface ContactData {\n  name: string;\n  email: string;\n  phone: string;\n  message: string;\n}\n\nconst EMAIL_REGEX = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\nconst PHONE_REGEX = /^\\+?[\\d\\s-]{10,}$/;\n\nexport function ContactForm({ onSubmit, initialValues }: ContactFormProps) {\n  const [values, setValues] = useState<ContactData>({\n    name: initialValues?.name || '',\n    email: initialValues?.email || '',\n    phone: initialValues?.phone || '',\n    message: initialValues?.message || '',\n  });\n  const [errors, setErrors] = useState<Partial<Record<keyof ContactData, string>>>({});\n  const [submitting, setSubmitting] = useState(false);\n  const [submitted, setSubmitted] = useState(false);\n\n  const validate = (): boolean => {\n    const newErrors: Partial<Record<keyof ContactData, string>> = {};\n    if (!values.name.trim()) newErrors.name = 'Name is required';\n    if (!EMAIL_REGEX.test(values.email)) newErrors.email = 'Invalid email';\n    if (values.phone && !PHONE_REGEX.test(values.phone)) newErrors.phone = 'Invalid phone';\n    if (!values.message.trim()) newErrors.message = 'Message is required';\n    if (values.message.length > 1000) newErrors.message = 'Message too long (max 1000 chars)';\n    setErrors(newErrors);\n    return Object.keys(newErrors).length === 0;\n  };\n\n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n    if (!validate()) return;\n    setSubmitting(true);\n    try {\n      await onSubmit(values);\n      setSubmitted(true);\n    } catch {\n      setErrors({ name: 'Submission failed. Please try again.' });\n    } finally {\n      setSubmitting(false);\n    }\n  };\n\n  if (submitted) return <div role=\"alert\">Thank you! Your message has been sent.</div>;\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input name=\"name\" value={values.name} onChange={e => setValues(v => ({...v, name: e.target.value}))} placeholder=\"Name\" />\n      {errors.name && <span role=\"alert\">{errors.name}</span>}\n      <input name=\"email\" value={values.email} onChange={e => setValues(v => ({...v, email: e.target.value}))} placeholder=\"Email\" type=\"email\" />\n      {errors.email && <span role=\"alert\">{errors.email}</span>}\n      <input name=\"phone\" value={values.phone} onChange={e => setValues(v => ({...v, phone: e.target.value}))} placeholder=\"Phone\" />\n      {errors.phone && <span role=\"alert\">{errors.phone}</span>}\n      <textarea name=\"message\" value={values.message} onChange={e => setValues(v => ({...v, message: e.target.value}))} placeholder=\"Message\" />\n      {errors.message && <span role=\"alert\">{errors.message}</span>}\n      <button type=\"submit\" disabled={submitting}>{submitting ? 'Sending...' : 'Send'}</button>\n    </form>\n  );\n}\n```", "expected_behavior": "Tests should cover: renders all fields, renders with initial values, validation errors for empty required fields, email validation, optional phone validation, message length validation, successful submission flow, failed submission shows error, submit button disabled while submitting, success message after submit", "stack": "react", "rubric": "Must use @testing-library/react with userEvent. Must test all validation rules (name required, email format, optional phone format, message required, message length). Must test successful submit flow end-to-end. Must test error handling on submit failure. Should test initial values. Should test disabled button during submission. Should test success message display. Should use accessible queries (getByRole, getByPlaceholderText)."}
