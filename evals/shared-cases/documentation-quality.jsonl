{"id": "doc-001", "prompt": "Generate documentation for this Rails service object:\n```ruby\nclass OrderFulfillmentService\n  FULFILLMENT_TIMEOUT = 30.minutes\n  MAX_RETRY_ATTEMPTS = 3\n\n  def initialize(order, warehouse: nil, notify: true)\n    @order = order\n    @warehouse = warehouse || WarehouseSelector.new(order).best_match\n    @notify = notify\n    @attempts = 0\n  end\n\n  def fulfill!\n    validate_order!\n    reserve_inventory\n    charge_payment\n    create_shipment\n    send_notifications if @notify\n    @order.update!(status: 'fulfilled', fulfilled_at: Time.current)\n  rescue InventoryError => e\n    handle_inventory_failure(e)\n  rescue PaymentError => e\n    rollback_inventory\n    raise\n  rescue ShipmentError => e\n    retry_or_fail(e)\n  end\n\n  private\n\n  def validate_order!\n    raise InvalidOrderError unless @order.valid?\n    raise AlreadyFulfilledError if @order.fulfilled?\n    raise ExpiredOrderError if @order.created_at < FULFILLMENT_TIMEOUT.ago\n  end\n\n  def reserve_inventory\n    @reservation = @warehouse.reserve(@order.line_items)\n  end\n\n  def charge_payment\n    PaymentService.new(@order.user, @order.total).charge!\n  end\n\n  def create_shipment\n    ShipmentService.create(order: @order, warehouse: @warehouse)\n  end\n\n  def send_notifications\n    OrderMailer.fulfilled(@order).deliver_later\n    SlackNotifier.order_fulfilled(@order)\n  end\n\n  def retry_or_fail(error)\n    @attempts += 1\n    if @attempts < MAX_RETRY_ATTEMPTS\n      sleep(2 ** @attempts)\n      create_shipment\n    else\n      @order.update!(status: 'fulfillment_failed')\n      AdminNotifier.fulfillment_failed(@order, error)\n      raise\n    end\n  end\nend\n```", "expected_behavior": "Documentation should include: class overview, constructor parameters and defaults, public API (fulfill! method), error handling flow, retry logic, constants explanation, dependencies, usage examples", "stack": "rails", "rubric": "Must document the fulfill! method with its full lifecycle. Must explain error handling strategy (rollback on payment failure, retry on shipment failure). Must document constructor parameters including defaults. Should include usage examples. Should list exceptions that can be raised. Should explain the timeout and retry constants. Should note dependencies (WarehouseSelector, PaymentService, ShipmentService)."}
{"id": "doc-002", "prompt": "Generate API documentation for these Express.js endpoints:\n```typescript\nrouter.get('/api/v1/projects', authenticate, async (req, res) => {\n  const { page = 1, perPage = 20, status, search, sortBy = 'created_at', order = 'desc' } = req.query;\n  const filters = { userId: req.user.id, status, search };\n  const projects = await ProjectService.list(filters, { page, perPage, sortBy, order });\n  res.json(projects);\n});\n\nrouter.get('/api/v1/projects/:id', authenticate, async (req, res) => {\n  const project = await ProjectService.findById(req.params.id, req.user.id);\n  if (!project) return res.status(404).json({ error: 'Project not found' });\n  res.json(project);\n});\n\nrouter.post('/api/v1/projects', authenticate, validate(createProjectSchema), async (req, res) => {\n  const project = await ProjectService.create({ ...req.body, userId: req.user.id });\n  res.status(201).json(project);\n});\n\nrouter.patch('/api/v1/projects/:id', authenticate, authorize('owner'), validate(updateProjectSchema), async (req, res) => {\n  const project = await ProjectService.update(req.params.id, req.body);\n  res.json(project);\n});\n\nrouter.delete('/api/v1/projects/:id', authenticate, authorize('owner'), async (req, res) => {\n  await ProjectService.softDelete(req.params.id);\n  res.status(204).end();\n});\n\nrouter.post('/api/v1/projects/:id/archive', authenticate, authorize('owner', 'admin'), async (req, res) => {\n  const project = await ProjectService.archive(req.params.id);\n  res.json(project);\n});\n```", "expected_behavior": "Documentation should include: endpoint table, request/response formats, authentication requirements, authorization requirements, query parameters, error responses, status codes, example curl commands", "stack": "node", "rubric": "Must document all 6 endpoints with method, path, and description. Must include authentication and authorization requirements per endpoint. Must document query parameters for list endpoint with defaults. Should include request/response body examples. Should list all possible HTTP status codes per endpoint. Should include example curl commands or similar. Should follow REST API documentation conventions."}
{"id": "doc-003", "prompt": "Generate documentation for this Python data pipeline:\n```python\nfrom dataclasses import dataclass, field\nfrom typing import List, Callable, Optional, Any\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass PipelineStep:\n    name: str\n    transform: Callable[[Any], Any]\n    skip_on_error: bool = False\n    timeout: int = 300\n\n@dataclass\nclass PipelineResult:\n    success: bool\n    data: Any\n    steps_completed: List[str] = field(default_factory=list)\n    errors: List[dict] = field(default_factory=list)\n    metadata: dict = field(default_factory=dict)\n\nclass DataPipeline:\n    def __init__(self, name: str, steps: Optional[List[PipelineStep]] = None):\n        self.name = name\n        self.steps = steps or []\n        self._hooks = {'before': [], 'after': [], 'error': []}\n\n    def add_step(self, name: str, transform: Callable, skip_on_error: bool = False, timeout: int = 300) -> 'DataPipeline':\n        self.steps.append(PipelineStep(name, transform, skip_on_error, timeout))\n        return self\n\n    def on(self, event: str, callback: Callable) -> 'DataPipeline':\n        if event not in self._hooks:\n            raise ValueError(f\"Unknown event: {event}. Valid: {list(self._hooks.keys())}\")\n        self._hooks[event].append(callback)\n        return self\n\n    def execute(self, data: Any) -> PipelineResult:\n        result = PipelineResult(success=True, data=data)\n        self._run_hooks('before', data)\n\n        for step in self.steps:\n            try:\n                logger.info(f\"Pipeline '{self.name}': executing step '{step.name}'\")\n                result.data = step.transform(result.data)\n                result.steps_completed.append(step.name)\n            except Exception as e:\n                logger.error(f\"Pipeline '{self.name}': step '{step.name}' failed: {e}\")\n                result.errors.append({'step': step.name, 'error': str(e)})\n                self._run_hooks('error', e)\n                if not step.skip_on_error:\n                    result.success = False\n                    break\n\n        self._run_hooks('after', result)\n        return result\n\n    def _run_hooks(self, event: str, context: Any):\n        for hook in self._hooks.get(event, []):\n            try:\n                hook(context)\n            except Exception as e:\n                logger.warning(f\"Hook failed for event '{event}': {e}\")\n```", "expected_behavior": "Documentation should include: module overview, class descriptions, builder pattern usage, hook system explanation, error handling behavior (skip_on_error), PipelineResult structure, complete usage examples from construction through execution", "stack": "python", "rubric": "Must document DataPipeline class with all public methods. Must explain the builder/chaining pattern (methods return self). Must document the hook system (before, after, error events). Must explain skip_on_error behavior. Should include complete end-to-end usage example. Should document PipelineStep and PipelineResult dataclasses. Should note logging behavior. Should explain error propagation vs. skip semantics."}
{"id": "doc-004", "prompt": "Generate inline documentation and JSDoc for this React context:\n```tsx\nimport React, { createContext, useContext, useReducer, useCallback, useMemo } from 'react';\n\ntype Theme = 'light' | 'dark' | 'system';\ntype Language = 'en' | 'es' | 'fr' | 'de' | 'ja';\n\ninterface Preferences {\n  theme: Theme;\n  language: Language;\n  fontSize: number;\n  notifications: boolean;\n  compactMode: boolean;\n}\n\ntype Action =\n  | { type: 'SET_THEME'; payload: Theme }\n  | { type: 'SET_LANGUAGE'; payload: Language }\n  | { type: 'SET_FONT_SIZE'; payload: number }\n  | { type: 'TOGGLE_NOTIFICATIONS' }\n  | { type: 'TOGGLE_COMPACT_MODE' }\n  | { type: 'RESET' }\n  | { type: 'LOAD'; payload: Partial<Preferences> };\n\nconst DEFAULT_PREFERENCES: Preferences = {\n  theme: 'system',\n  language: 'en',\n  fontSize: 16,\n  notifications: true,\n  compactMode: false,\n};\n\nfunction preferencesReducer(state: Preferences, action: Action): Preferences {\n  switch (action.type) {\n    case 'SET_THEME': return { ...state, theme: action.payload };\n    case 'SET_LANGUAGE': return { ...state, language: action.payload };\n    case 'SET_FONT_SIZE': return { ...state, fontSize: Math.max(12, Math.min(24, action.payload)) };\n    case 'TOGGLE_NOTIFICATIONS': return { ...state, notifications: !state.notifications };\n    case 'TOGGLE_COMPACT_MODE': return { ...state, compactMode: !state.compactMode };\n    case 'RESET': return DEFAULT_PREFERENCES;\n    case 'LOAD': return { ...DEFAULT_PREFERENCES, ...action.payload };\n    default: return state;\n  }\n}\n\nconst PreferencesContext = createContext<{\n  preferences: Preferences;\n  setTheme: (theme: Theme) => void;\n  setLanguage: (language: Language) => void;\n  setFontSize: (size: number) => void;\n  toggleNotifications: () => void;\n  toggleCompactMode: () => void;\n  reset: () => void;\n  load: (prefs: Partial<Preferences>) => void;\n} | null>(null);\n\nexport function PreferencesProvider({ children, initialPreferences }: { children: React.ReactNode; initialPreferences?: Partial<Preferences> }) {\n  const [preferences, dispatch] = useReducer(preferencesReducer, { ...DEFAULT_PREFERENCES, ...initialPreferences });\n\n  const setTheme = useCallback((theme: Theme) => dispatch({ type: 'SET_THEME', payload: theme }), []);\n  const setLanguage = useCallback((language: Language) => dispatch({ type: 'SET_LANGUAGE', payload: language }), []);\n  const setFontSize = useCallback((size: number) => dispatch({ type: 'SET_FONT_SIZE', payload: size }), []);\n  const toggleNotifications = useCallback(() => dispatch({ type: 'TOGGLE_NOTIFICATIONS' }), []);\n  const toggleCompactMode = useCallback(() => dispatch({ type: 'TOGGLE_COMPACT_MODE' }), []);\n  const reset = useCallback(() => dispatch({ type: 'RESET' }), []);\n  const load = useCallback((prefs: Partial<Preferences>) => dispatch({ type: 'LOAD', payload: prefs }), []);\n\n  const value = useMemo(() => ({\n    preferences, setTheme, setLanguage, setFontSize, toggleNotifications, toggleCompactMode, reset, load\n  }), [preferences, setTheme, setLanguage, setFontSize, toggleNotifications, toggleCompactMode, reset, load]);\n\n  return <PreferencesContext.Provider value={value}>{children}</PreferencesContext.Provider>;\n}\n\nexport function usePreferences() {\n  const context = useContext(PreferencesContext);\n  if (!context) throw new Error('usePreferences must be used within PreferencesProvider');\n  return context;\n}\n```", "expected_behavior": "Documentation should include: JSDoc for all exported functions and types, module overview comment, explanation of the reducer pattern, font size clamping behavior, context usage pattern, provider setup example, hook usage example", "stack": "react", "rubric": "Must add JSDoc to PreferencesProvider and usePreferences. Must document all types/interfaces. Must explain the reducer pattern and available actions. Must document font size clamping (12-24). Should include provider setup example. Should include hook consumption example. Should document the error thrown when used outside provider. Should explain memoization strategy."}
{"id": "doc-005", "prompt": "Generate README-style documentation for this Go package:\n```go\npackage cache\n\nimport (\n\t\"sync\"\n\t\"time\"\n)\n\ntype entry struct {\n\tvalue     interface{}\n\texpiresAt time.Time\n}\n\ntype Cache struct {\n\tmu       sync.RWMutex\n\tentries  map[string]entry\n\tdefaultTTL time.Duration\n\tmaxSize  int\n\tonEvict  func(key string, value interface{})\n}\n\ntype Option func(*Cache)\n\nfunc WithTTL(ttl time.Duration) Option {\n\treturn func(c *Cache) { c.defaultTTL = ttl }\n}\n\nfunc WithMaxSize(size int) Option {\n\treturn func(c *Cache) { c.maxSize = size }\n}\n\nfunc WithEvictionCallback(fn func(string, interface{})) Option {\n\treturn func(c *Cache) { c.onEvict = fn }\n}\n\nfunc New(opts ...Option) *Cache {\n\tc := &Cache{\n\t\tentries:    make(map[string]entry),\n\t\tdefaultTTL: 5 * time.Minute,\n\t\tmaxSize:    1000,\n\t}\n\tfor _, opt := range opts {\n\t\topt(c)\n\t}\n\tgo c.cleanup()\n\treturn c\n}\n\nfunc (c *Cache) Set(key string, value interface{}, ttl ...time.Duration) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tt := c.defaultTTL\n\tif len(ttl) > 0 { t = ttl[0] }\n\tif len(c.entries) >= c.maxSize { c.evictOldest() }\n\tc.entries[key] = entry{value: value, expiresAt: time.Now().Add(t)}\n}\n\nfunc (c *Cache) Get(key string) (interface{}, bool) {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\te, ok := c.entries[key]\n\tif !ok || time.Now().After(e.expiresAt) { return nil, false }\n\treturn e.value, true\n}\n\nfunc (c *Cache) Delete(key string) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tif e, ok := c.entries[key]; ok && c.onEvict != nil {\n\t\tc.onEvict(key, e.value)\n\t}\n\tdelete(c.entries, key)\n}\n\nfunc (c *Cache) Len() int {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\treturn len(c.entries)\n}\n\nfunc (c *Cache) cleanup() {\n\tticker := time.NewTicker(time.Minute)\n\tfor range ticker.C {\n\t\tc.mu.Lock()\n\t\tnow := time.Now()\n\t\tfor k, e := range c.entries {\n\t\t\tif now.After(e.expiresAt) {\n\t\t\t\tif c.onEvict != nil { c.onEvict(k, e.value) }\n\t\t\t\tdelete(c.entries, k)\n\t\t\t}\n\t\t}\n\t\tc.mu.Unlock()\n\t}\n}\n\nfunc (c *Cache) evictOldest() {\n\tvar oldestKey string\n\tvar oldestTime time.Time\n\tfor k, e := range c.entries {\n\t\tif oldestKey == \"\" || e.expiresAt.Before(oldestTime) {\n\t\t\toldestKey = k\n\t\t\toldestTime = e.expiresAt\n\t\t}\n\t}\n\tif oldestKey != \"\" {\n\t\tif c.onEvict != nil { c.onEvict(oldestKey, c.entries[oldestKey].value) }\n\t\tdelete(c.entries, oldestKey)\n\t}\n}\n```", "expected_behavior": "Documentation should include: package overview, functional options pattern explanation, thread safety notes, TTL and eviction behavior, all public methods, usage examples with options, cleanup goroutine behavior", "stack": "go", "rubric": "Must document all public functions and methods (New, Set, Get, Delete, Len, options). Must explain the functional options pattern. Must note thread safety (sync.RWMutex). Must document TTL behavior and defaults. Should include usage examples. Should explain eviction policy (oldest by expiry). Should note the background cleanup goroutine. Should document the eviction callback."}
{"id": "doc-006", "prompt": "Generate documentation for this Rails API serializer pattern:\n```ruby\nclass BaseSerializer\n  class << self\n    def attributes(*attrs)\n      @attributes = attrs\n    end\n\n    def has_many(name, serializer:)\n      @associations ||= {}\n      @associations[name] = { type: :has_many, serializer: serializer }\n    end\n\n    def belongs_to(name, serializer:)\n      @associations ||= {}\n      @associations[name] = { type: :belongs_to, serializer: serializer }\n    end\n\n    def get_attributes\n      @attributes || []\n    end\n\n    def get_associations\n      @associations || {}\n    end\n  end\n\n  def initialize(object, options = {})\n    @object = object\n    @options = options\n    @include = options.fetch(:include, [])\n    @fields = options.fetch(:fields, nil)\n  end\n\n  def serialize\n    result = {}\n    attrs = self.class.get_attributes\n    attrs = attrs & @fields if @fields\n    attrs.each { |attr| result[attr] = resolve_attribute(attr) }\n    serialize_associations(result)\n    result\n  end\n\n  def serialize_collection(collection)\n    collection.map { |item| self.class.new(item, @options).serialize }\n  end\n\n  private\n\n  def resolve_attribute(attr)\n    respond_to?(attr, true) ? send(attr) : @object.send(attr)\n  end\n\n  def serialize_associations(result)\n    self.class.get_associations.each do |name, config|\n      next unless @include.include?(name)\n      associated = @object.send(name)\n      serializer_class = config[:serializer]\n      result[name] = if config[:type] == :has_many\n        serializer_class.new(nil, @options).serialize_collection(associated)\n      else\n        associated ? serializer_class.new(associated, @options).serialize : nil\n      end\n    end\n  end\nend\n```", "expected_behavior": "Documentation should include: class overview and purpose, DSL explanation (attributes, has_many, belongs_to), serialization behavior, options (include, fields), custom attribute methods, inheritance pattern, usage examples with a concrete serializer subclass", "stack": "rails", "rubric": "Must document the DSL methods (attributes, has_many, belongs_to). Must explain the options hash (include for associations, fields for sparse fieldsets). Must show a concrete subclass example. Should explain custom attribute resolution (method override vs object delegation). Should document serialize vs serialize_collection. Should explain the include filtering for associations. Should note the inheritance pattern."}
{"id": "doc-007", "prompt": "Generate documentation for this TypeScript event bus:\n```typescript\ntype EventHandler<T = any> = (payload: T) => void | Promise<void>;\ntype Unsubscribe = () => void;\n\ninterface EventMap {\n  [event: string]: any;\n}\n\nclass TypedEventBus<Events extends EventMap> {\n  private handlers: Map<keyof Events, Set<EventHandler>> = new Map();\n  private onceHandlers: Map<keyof Events, Set<EventHandler>> = new Map();\n  private history: Map<keyof Events, Events[keyof Events][]> = new Map();\n  private maxHistorySize: number;\n\n  constructor(options: { maxHistorySize?: number } = {}) {\n    this.maxHistorySize = options.maxHistorySize ?? 100;\n  }\n\n  on<K extends keyof Events>(event: K, handler: EventHandler<Events[K]>): Unsubscribe {\n    if (!this.handlers.has(event)) this.handlers.set(event, new Set());\n    this.handlers.get(event)!.add(handler);\n    return () => this.handlers.get(event)?.delete(handler);\n  }\n\n  once<K extends keyof Events>(event: K, handler: EventHandler<Events[K]>): Unsubscribe {\n    if (!this.onceHandlers.has(event)) this.onceHandlers.set(event, new Set());\n    this.onceHandlers.get(event)!.add(handler);\n    return () => this.onceHandlers.get(event)?.delete(handler);\n  }\n\n  async emit<K extends keyof Events>(event: K, payload: Events[K]): Promise<void> {\n    this.recordHistory(event, payload);\n    const handlers = this.handlers.get(event);\n    const onceHandlers = this.onceHandlers.get(event);\n    const all = [...(handlers ?? []), ...(onceHandlers ?? [])];\n    await Promise.all(all.map(h => h(payload)));\n    this.onceHandlers.delete(event);\n  }\n\n  getHistory<K extends keyof Events>(event: K): Events[K][] {\n    return (this.history.get(event) as Events[K][]) ?? [];\n  }\n\n  clearHistory(event?: keyof Events): void {\n    if (event) this.history.delete(event);\n    else this.history.clear();\n  }\n\n  removeAllListeners(event?: keyof Events): void {\n    if (event) {\n      this.handlers.delete(event);\n      this.onceHandlers.delete(event);\n    } else {\n      this.handlers.clear();\n      this.onceHandlers.clear();\n    }\n  }\n\n  private recordHistory<K extends keyof Events>(event: K, payload: Events[K]): void {\n    if (!this.history.has(event)) this.history.set(event, []);\n    const hist = this.history.get(event)!;\n    hist.push(payload);\n    if (hist.length > this.maxHistorySize) hist.shift();\n  }\n}\n```", "expected_behavior": "Documentation should include: class overview, type safety explanation via generic EventMap, all public methods (on, once, emit, getHistory, clearHistory, removeAllListeners), unsubscribe pattern, event history feature, async emit behavior, usage example with typed events", "stack": "typescript", "rubric": "Must document all public methods with parameters and return types. Must explain the generic type parameter for type-safe events. Must show a typed usage example defining an EventMap interface. Should explain the unsubscribe function returned by on/once. Should document the history feature and maxHistorySize. Should explain async emit behavior (Promise.all). Should note once handler cleanup after emit."}
