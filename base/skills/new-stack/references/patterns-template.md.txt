# FRAMEWORK Code Patterns

This document contains code patterns and examples for FRAMEWORK development.
All code should follow these patterns for consistency.

## Quick Reference

| Pattern | When to Use | Example |
|---------|-------------|---------|
| Model | Data entities | `User`, `Product` |
| Controller/View | HTTP endpoints | `UsersController` |
| Service | Business logic | `PaymentService` |
| Repository | Data access | `UserRepository` |

---

## 1. Model Pattern

### When to Use
- Representing database entities
- Data validation
- Relationships between entities

### Example

```LANGUAGE
# FRAMEWORK model example
# Replace with actual framework-specific code

class ModelName:
    # Fields
    id: int
    name: str
    created_at: datetime

    # Relationships
    # related_items: List[RelatedModel]

    # Validations
    # validate name is not empty
```

### Key Points
- Always include timestamps (created_at, updated_at)
- Define relationships explicitly
- Add validations at the model level
- Use appropriate field types

---

## 2. Controller/View/Router Pattern

### When to Use
- Handling HTTP requests
- Input validation
- Response formatting

### Example

```LANGUAGE
# FRAMEWORK controller/view example
# Replace with actual framework-specific code

class ResourceController:
    def index(self, request):
        """List all resources."""
        resources = ResourceService.list()
        return Response(resources)

    def show(self, request, id):
        """Get a single resource."""
        resource = ResourceService.get(id)
        if not resource:
            return NotFound()
        return Response(resource)

    def create(self, request):
        """Create a new resource."""
        data = validate(request.body)
        resource = ResourceService.create(data)
        return Response(resource, status=201)
```

### Key Points
- Keep controllers thin
- Delegate to services for business logic
- Validate input at the controller level
- Return appropriate status codes

---

## 3. Service Pattern

### When to Use
- Complex business logic
- Operations spanning multiple models
- Reusable operations

### Example

```LANGUAGE
# FRAMEWORK service example
# Replace with actual framework-specific code

class ResourceService:
    def __init__(self, repository):
        self.repository = repository

    def list(self, filters=None):
        """List resources with optional filtering."""
        return self.repository.find_all(filters)

    def create(self, data):
        """Create a resource with business logic."""
        # Validate business rules
        # Create the resource
        # Trigger side effects (notifications, etc.)
        return self.repository.create(data)
```

### Key Points
- One service per domain concept
- Inject dependencies
- Keep methods focused
- Handle errors gracefully

---

## 4. Schema/Serializer Pattern

### When to Use
- API request/response formatting
- Data validation
- Data transformation

### Example

```LANGUAGE
# FRAMEWORK schema/serializer example
# Replace with actual framework-specific code

class ResourceSchema:
    # Input schema (for create/update)
    class Create:
        name: str  # required
        description: str | None = None  # optional

    # Output schema (for responses)
    class Response:
        id: int
        name: str
        description: str | None
        created_at: datetime
```

### Key Points
- Separate input and output schemas
- Use explicit types
- Mark optional fields clearly
- Include validation rules

---

## 5. Test Pattern

### When to Use
- All new code should have tests
- Unit tests for services
- Integration tests for controllers

### Example

```LANGUAGE
# FRAMEWORK test example
# Replace with actual framework-specific code

class TestResourceService:
    def test_create_resource(self):
        # Arrange
        data = {"name": "Test"}

        # Act
        result = service.create(data)

        # Assert
        assert result.name == "Test"
        assert result.id is not None

    def test_create_resource_validates_name(self):
        # Arrange
        data = {"name": ""}

        # Act & Assert
        with pytest.raises(ValidationError):
            service.create(data)
```

### Key Points
- Use Arrange-Act-Assert pattern
- Test happy path and edge cases
- Mock external dependencies
- Use descriptive test names

---

## Directory Structure

```
PROJECT_STRUCTURE
├── models/          # or entities/, domain/
├── controllers/     # or views/, routers/
├── services/
├── schemas/         # or serializers/
├── repositories/    # if using repository pattern
└── tests/
```
